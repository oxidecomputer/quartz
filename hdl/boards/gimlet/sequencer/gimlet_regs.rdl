// Copyright 2021 Oxide Computer Company
// This is SystemRDL description of the sw-accesible registers in the Gimlet
// Sequencer FPGA.

addrmap gimlet_seq_fpga {
    name = "Gimlet Sequencer FPGA";
    desc = "Register description of the Gimlet Sequencer FPGA";

    default regwidth = 8;
    default sw = rw;
    default hw = r;

    reg {
        name = "Identification 0";
        default sw = r;
        
        field {
            desc = "TBD";
        } TBD[7:0] = 0;
    } ID0;
    reg {
        name = "Identification 1";
        default sw = r;
        
        field {
            desc = "TBD";
        } TBD[7:0] = 0;
    } ID1;
    reg {
        name = "Identification 2";
        default sw = r;

        field {
            desc = "TBD";
        } TBD[7:0] = 0;
    } ID2;
    reg {
        name = "Identification 3";
        default sw = r;

        field {
            desc = "TBD";
        } TBD[7:0] = 0;
    } ID3;

    reg irq_type {
        field {
            desc = "Fan Power Timeout";
        } FANTIMEOUT[1];
        field {
            desc = "Fan Power Fault";
        } FANFAULT[1];
        field {
            desc = "A1 Power-up Timeout";
        } A1TIMEOUT[1];
        field {
            desc = "A1 Fault";
        } A1FAULT[1];
        field {
            desc = "A0 Power-up Timeout";
        } A0TIMEOUT[1];
        field {
            desc = "A0 Fault";
        } A0FAULT[1];

    };

    // Set up interrupt registers using a common irq_type
    irq_type IFR;
    IFR->name = "Interrupt Flag Register"; 
    irq_type IER;
    IER->name = "Interrupt Enable Register";

    reg {
        name = "Sequencer Status Register";
        default sw = r;
        
        field {
            desc = "Fan power OK";
        } FANPWROK[1] = 0;
        field {
            desc = "A1 power OK";
        } A1PWROK[1] = 0;
        field {
            desc = "NIC power OK";
        } NICPWROK[1] = 0;
        field {
            desc = "A0 power OK";
        } A0PWROK[1] = 0;
        field {
            desc = "Interrupt Pending Status";
        } INT[7:7] = 0;
    } STATUS;

    reg {
        name = "Early Power Control Register";
        field {
            desc = "Fan power enable";
        } FANPWREN[1] = 0;
        field {
            desc = "Enables V2P5_DIMM_ABCD_SPD_A0 rail (SEQ_TO_DIMM_ABCD_V2P5_EN net).";
        } ABCD_SPD_EN[1] = 0;
        field {
            desc = "Enables V2P5_DIMM_EFGH_SPD_A0 rail. (SEQ_TO_DIMM_EFGH_V2P5_EN net).";
        } EFGH_SPD_EN[1] = 0;
    } EARLY_PWRCTRL;
    
    reg { 
        field {
            desc = "A1 power enable (starts state machine)";
        } A1PWREN[1] = 0;
        field {
            desc = "A0 Group A power enable (starts state machine)";
        } A0A_EN[1] = 0;
        field {
            desc = "A0 Group B power enable (starts state machine)";
        } A0B_EN[1] = 0;
        field {
            desc = "A0 Group C power stages occur autonomously (assuming SMBus commands turn on the 
            RA229618 outputs) *unless* this bit is set.";
        } A0C_DIS[1] = 0;
        field {
            desc = "NIC power enable (starts state machine)";
        } NICPWREN[1] = 0;
         field {
            desc = "External pull-up give SP control of restarting. 
            Falling edge triggers restart function which tags 2-25sec 
            (default 10s) set by PMBus registers. 10us glitch filter at ADM1272.
            Writing to this will cause a strobe that exceeds the glitch filter
            timing and will self-clear (note actual output is inverted to meet
            circuit's active low requirement";
            singlepulse = true;
        } FANHP_RESTART[7:7] = 0;
    } PWRCTRL;

    // Readback blocks:
    // These are built as contiguous registers so that a single multi-byte read 
    // could capture all of them.

    // Readbacks of pins for FAN-power related things
    reg {
        name = "Pre-A1 Power Readback Register";
        default sw = r;

        field {
            desc = "Input from ADM1272. Rising edge enable PMBus OPERATION on
            command or PMBus POWER_CYCLE required to clear, assuming all
            faults are clear.";
        } FANHP_TO_SEQ_FAULT_L[1] = 0;
        field {
            desc = "From ADUM1272. Asserted when PWGIN > thresh, enable pin is
            high and UVx and OV pins are in-range, no actuive fault conditons 
            and mosfet is fully enhanced (Vgs > 10V).";
        } FANHP_TO_SEQ_PWRGD[1] = 0;
        field {
            desc = "Input from ADM1272. Rising edge enable PMBus OPERATION on 
            command or PMBus POWER_CYCLE required to clear, assuming all faults 
            are clear.";
        } FAN_TO_SEQ_FAN_FAIL[1] = 0;
        field {
            desc = "Readback for V2P5_DIMM_ABCD_SPD_A0 rail (DIMM_TO_SEQ_ABCD_V2P5_PG net)";

        } ABCD_V2P5_SPD_PG[1] = 0;
        field {
            desc = "Readback for V2P5_DIMM_EFGH_SPD_A0 rail (DIMM_TO_SEQ_EFGH_V2P5_PG net)";

        } EFGH_V2P5_SPD_PG[1] = 0;
    } EARLY_RBKS;

    reg {
        name = "A1 SM Status";
        desc = "A1 'live' state machine status";
        default sw = r;

        field {
            desc = "TBD";
        } A1SM[7:0];
        // TODO: A1 state machine decode in here
    } A1SMSTATUS;
    // Readbacks of pins for A1-power related things
    reg {
        name = "A1 power readbacks";
        default sw = r;

        field {
            desc = "Readback for V1P5_SP_VDD_RTC_A1 rail.
            (SP3_TO_SEQ_RTC_V1P5_EN - a poor net name)";
        } V1P5_RTC_PG[1] = 0;

        field {
            desc = "Readback for V3P3_SP3_VDD_33_S5_A1 rail 
            (SP3_TO_SEQ_V3P3_S5_PG)";
        } V3P3_S5_PG[1] = 0;
        field {
            desc = "Readback for V1P8_SP3_VDD_18_S5_A rail 
            (SP3_TO_SEQ_V1P8_S5_PG)";
        } V1P8_S5_PG[1] = 0;
        field {
            desc = "Readback for V0P9_SP3_VDD_SOC_S5_A1 rail 
            (SP3_TO_SEQ_V0P9_VDD_SOC_S5_PG)";
        } V0P9_VDD_SOC_S5_PG[1] = 0;
    } A1READBACKS;

    // Readbacks of pins for A0-power related things
    reg {
        name = "AMD readbacks for A0-signals";
        default sw = r;

        field {
            desc = "SP3_TO_SP_SLP_S3 inversion of signal from AMD CPU, Used
            at beginning of GroupB state machine";
        } SLP_S3[1] = 0;
        field {
            desc = "SP3_TO_SP_SLP_S5 inversion of signal from AMD CPU, Used 
            at beginning of GroupB state machine";
        } SLP_S5[1] = 0;
        field {
            desc = "Asserted by AMD after PWR_GOOD is asserted by sequencer 
            should be here in: min 15ms, max of 20.4ms(SP3_TO_SEQ_PWROK_V3P3 net)";
        } PWROK[1] = 0;
        field {
            desc = "Asserted (and inverted) from AMDâ€™s RESET_L pin. 10Ms minimum assertion time, 
            remains asserted for minimum of 1ms after PWROK assertion
            (SP3_TO_SEQ_RESET_V3P3_L net)";
        } RESET[1] = 0;
    } AMD_A0;

    reg {
        name = "A0 Power Goods for Group B supplies";
        default sw = r;

        field {
            desc = "Readback from VPP_ABCD_A0 rail (PWR_CONT_DIMM_ABCD_PG0 net)";
        } VPP_ABCD_PG[1] = 0;
        field {
            desc = "Readback from VPP_EFGH_A0 rail (PWR_CONT_DIMM_EFGH_PG0 net)";
        } VPP_EFGH_PG[1] = 0;
        field {
            desc = "Readback from VDD_MEM_ABCD_A0 rail (PWR_CONT1_SP3_PG0)
            Power good 0 for RA229618 (U350) should be configured for 
            VDD_MEM_ABCD_A0";
        } VDD_MEM_ABCD_PG[1];
        field {
            desc = "Readback from VDD_MEM_EFGH_A0 rail (PWR_CONT2_SP3_PG0)
            Power good 0 for RA229618 (U351) should be configured for 
            VDD_MEM_EFGH_A0";
        } VDD_MEM_EFGH_PG[1];
        field {
            desc = "Readback for VTT_ABCD_A0 rail (VTT_ABCD_A0_TO_SEQ_PG_L) inverted";
        } VTT_ABCD_PG[1];
        field {
            desc = "Readback for VTT_EFGH_A0 rail (VTT_EFGH_A0_TO_SEQ_PG_L) inverted";
        } VTT_EFGH_PG[1];
        field {
            desc = "Readback for V1P8_SP3_VDD_18_A0 rail (SEQ_V1P8_SP3_VDD_PG_L) inverted";
        } V1P8_SP3_PG[1];
        field {
            desc = "Readback from V3P3_SYS_A0 rail (PWR_CONT_DIMM_ABCD_PG1)
            PG1 from ISL68224 U352, should be configured to represent 
            V3P3_SYS_A0 rail status";
        } V3P3_SYS_PG[1] = 0;
    } GROUPB_PG;
    reg {
        name = "A0 Power Goods for Un-used supplies";
        default sw = r;

        field {
            desc = "From ISL68224 U352. PWR_CONT_DIMM_ABCD_PG2 net. No defined function.";
        } ABCD_PG2[1] = 0;

        field {
            desc = "From ISL68224 U418. PWR_CONT_DIMM_EFGH_PG1 net. No defined function.";
        } EFGH_PG1[1] = 0;

        field {
            desc = "From ISL68224 U418. PWR_CONT_DIMM_EFGH_PG2 net. No defined function.";
        } EFGH_PG2[1] = 0;
    } GROUPB_UNUSED;

    reg {
        name = "A0 Power Faults for Group B + C supplies";
        default sw = r;

        field {
            desc = "Set high (inverted from board) when rail reaches OT_WARN threshold, 
            only valid after configuration (PWR_CONT1_SP3_NVRHOT net).
            from RAA229618 U350 controlling SP3_VDD_VCORE_A0 and VDD_MEM_ABCD_A0 rails";
        } CONT1_NVRHOT[1] = 0;
        field {
            desc = "Catastrophic fault protection output from RAA229618 U350 controlling 
            SP3_VDD_VCORE_A0 and VDD_MEM_ABCD_A0 rails";
        } CONT1_CFP[1] = 0;
        field {
            desc = "Set high (inverted from board) when rail reaches OT_WARN threshold, 
            only valid after configuration from ISL68224 U352
             driving VPP_ABCD_A0 and V3P3_SYS_A0 rails. (PWR_CONT_DIMM_ABCD_NVRHOT net)";
        } ABCD_NVRHOT[1] = 0;
        field {
            desc = "Catastrophic fault protection output from ISL68224 feeding VPP_ABCD_A0 
            and V3P3_SYS_A0 rails. (PWR_CONT_DIMM_ABCD_CFP net)";
        } ABCD_CFP[1] = 0;
        field {
            desc = "Set high (inverted from board) when rail reaches OT_WARN threshold, 
            only valid after configuration from ISL68224 U418 driving VPP_EFGH_A0 rail.
            (PWR_CONT_DIMM_EFGH_NVRHOT net)";
        } EFGH_NVRHOT[1] = 0;
         field {
            desc = "Catastrophic fault protection output for ISL68224 and downstream devices
            driving VPP_EFGH_A0. (PWR_CONT_DIMM_EFGH_CFP net)";
        } EFGH_CFP[1] = 0;
        field {
            desc = "Set high (inverted from board) when rail reaches OT_WARN threshold, only valid 
            after configuration. From RAA229618 U351 driving rails SP3_VDDCR_SOC_A0 and 
            VDD_MEM_EFGH_A0 (PWR_CONT2_SP3_NVRHOT net)";
        } CONT2_NVRHOT[1] = 0;
         field {
            desc = "Catastrophic fault protection output from RAA229618 U351 controlling 
            SP3_VDDCR_SOC_A0 and VDD_MEM_EFGH_A0 rails (PWR_CONT2_SP3_CFP net).";
        } CONT2_CFP[1] = 0;
    } GROUPBC_FLTS;

    reg {
        name = "A0 STATUS for Group C supplies";
        default sw = r;

        field {
            desc = "Power good 1 for RA229618 (U351) should be configured for 
                    SP3_VDDCR_SOC_A0 (PWR_CONT2_SP3_PG1 net)";
        } VDDCR_SOC_PG[1] = 0;
        field {
            desc = "Power good 1 from RA229618 (U350) should be configured for
                    SP3_VDD_VCORE_A0 (PWR_CONT1_SP3_PG1 net)";
        } VDD_VCORE[1] = 0;
    } GROUPC_PG;

    // NIC readbacks
    reg {
        name = "Power Status for NIC HP supplies";
        default sw = r;
        
        field {
            desc = "Power goodÂ forÂ V0P96_NIC_VDD_A0HP (PWR_CONT_NIC_PG0 net)";
        } NIC_V0P96_PG[1] = 0;
        field {
            desc = "Power goodÂ forÂ V1P1_NIC_ETH_IO_A0HP (inverted NIC_TO_SEQ_V1P1_PG_L net)";
        } NIC_V1P1_PG[1] = 0;
        field {
            desc = "Power goodÂ forÂ V1P2_NIC_MDIO_A0HP  (inverted NIC_TO_SEQ_V1P2_PG_L net)";
        } NIC_V1P2_PG[1] = 0;
        field {
            desc = "Power goodÂ forÂ V1P5_NIC_AVDD_A0HP (inverted NIC_TO_SEQ_V1P5A_PG_L net)";
        } NIC_AV1P5_PG[1] = 0;
        field {
            desc = "Power goodÂ forÂ V1P5_NIC_PCIE_MEM_A0HP (inverted NIC_TO_SEQ_V1P5D_PG_L net)";
        } NIC_V1P5_PG[1] = 0;
        field {
            desc = "Power goodÂ forÂ V1P8_NIC_A0HP  (PWR_CONT_NIC_PG1 net)";
        } NIC_V1P8_PG[1] = 0;
        field {
            desc = "Set high (inverted from board)Â whenÂ railÂ reachesÂ OT_WARNÂ threshold,Â onlyÂ validÂ afterÂ 
            configuration (PWR_CONT_NIC_NVRHOT net)";
        } NIC_NVRHOT[1] = 0;
        field {
            desc = "CatastrophicÂ faultÂ protectionÂ output from ISL68224 U357 driving V1P8_NIC_A0HP 
            VOP96_NIC_VDD_A0HP (PWR_CONT_NIC_CFP)";
        } NIC_CFP[1] = 0;
    } NIC_STATUS;

    reg {
        name = "Cock Generator GPIO Readbacks";
        field {
            desc = "GPIO1";
        } GPIO1[1] = 0;
        field {
            desc = "GPIO2";
        } GPIO2[1] = 0;
        field {
            desc = "GPIO3";
        } GPIO3[1] = 0;
        field {
            desc = "GPIO4";
        } GPIO4[1] = 0;
        field {
            desc = "GPIO5";
        } GPIO5[1] = 0;
        field {
            desc = "GPIO8";
        } GPIO8[1] = 0;
        field {
            desc = "GPIO9";
        } GPIO9[1] = 0;
    } CLKGEN_STATUS;

    reg {
        name = "General AMD readbacks";
        field {
            desc = "inverted CPU's thermtrip_L, 500ms to shut down power planes into S5 state. De-assertion of PWROK resets THERMTRIP_L";
        } THERMTRIP[1] = 0;
        field {
            desc = "inverted FSR_REQ_L net. Maybe used in host reset detection, see RFD138. No defined use in power-up";
        } FSR_REQ[1] = 0;
        field {
            desc = "Output from the AMD processor that it has effectively acknowledged that power is itself
                    good.  This  is  connected  from  the  BSP  to  the  APâ€™s  PWR_GOOD  input  in  a  two  socket
                    system.  The  FCH  may  actually  control  this  being  generated  via  the
                    FCH::PM::RESETCONTROL2 register. ";
        } PWRGD_OUT[1] = 0;
    } AMD_STATUS;
  
    // We use this type to create both a status register for reading outputs
    // and the debug control register for forcing outputs.
    reg {
        name = "Fan Output Status";
        default sw = r;

        field {
            desc = "Enable for fan ADUM1272. (1us glitch filter at ADUM1272)";
        } FAN_HP_EN[1];
        field {
            desc = "FANHP_RESTART pin (note actual output is inverted to meet
            circuit's active low requirement, so a 1 here means a 0 on the board)";
        } FANHP_RESTART[1] = 0;
    } FANOUTSTATUS;

    reg a1_output_type {
        name = "A1 Outputs";
        default sw = r;

        field {
            desc = "Enables V3P3_SP3_VDD_33_S5_A1 rail (SEQ_TO_SP3_V3P3_S5_EN pin)";
        } V3P3_S5_EN[1] = 0;
        field {
            desc = "Enables V1P5_SP3_VDD_RTC_A1 rail (SEQ_TO_SP3_V1P5_RTC_EN pin)";
        } V1P5_RTC_EN[1] = 0;
        field {
            desc = "Enables V1P8_SP3_VDD_18_S5_A1 rail (SEQ_TO_SP3_V1P8_S5_EN pin)";
        } V1P8_S5_EN[1] = 0;
        field {
            desc = "Enables V0P9_SP3_VDD_SOC_S5_A1 rail (SEQ_TO_SP3_V0P9_S5_EN pin)";
        } V0P9_S5_EN[1] = 0;
    };

    reg a0_output1_type {
        field {
            desc = "Drives VPP_ABCD_A0 rail (PWR_CONT_DIMM_ABCD_EN0 net)";
        } VPP_ABCD_EN[1] = 0;
        field {
            desc = "Drives VPP_EFGH_A0 rail (PWR_CONT_DIMM_EFGH_EN0 net)";
        } VPP_EFGH_EN[1] = 0;
        field {
            desc = "Enables VTT_ABCD_A0 rail (SEQ_TO_VTT_ABCD_A0_EN net)";            
        } VTT_ABCD_EN[1] = 0;
        field {
            desc = "Enables VTT_EFGH_A0 rail, should enable in parallel with 
            PWR_CONT1_SP3_EN (SEQ_TO_VTT_EFGH_EN net)";
        } VTT_EFGH_EN[1] = 0;
        field {
            desc = "Drives EN of ISL68224 and ISL99390 UP32,33,34 for enabling the 
            V3P3_SYS_A0 rail (PWR_CONT_DIMM_ABCD_EN1 net)";
        } V3P3_SYS_EN[1] = 0;
        field {
            desc = "Enable 1 for ISL68224, no defined use (PWR_CONT_DIMM_EFGH_EN1 net)";
        } EFGH_EN1[1] = 0;
        field {
            desc = "EN2 of ISL68224 U352, no defined function (PWR_CONT_DIMM_ABCD_EN2 net)";
        } ABCD_EN2[1] = 0;
        field {
            desc = "To ISL68224 U418. No defined function (PWR_CONT_DIMM_EFGH_EN2 net)";
        } EFGH_EN2[1] = 0;
    };

    reg a0_output2_type {
        field {
            desc = "Strap High, no definition yet. PWROK pin to RAA229618 U350 driving 
            SP3_VDD_VCORE_A0 and VDD_MEM_ABCD_A0";
        } U350_PWROK[1] = 1;
        field {
            desc = "Strap High, no definition yet. PWROK pin to RAA229618 U351 driving
            SP3_VDDCR_SOC_A0 and VDD_MEM_EFGH_A0 (PWR_CONT2_SP3_PWROK net)";
        } U351_PWROK[1] = 1;
        field {
            desc = "Enables V1P8_SP3_VDD_18_A0 rail (SEQ_TO_SP3_V1P8_EN net)";
        } V1P8_SP3_EN[1] = 0;
        field {
            desc = "Enable for RAA229618 (U350) VDD_MEM_ABCD_A0 (PWR_CONT1_SP3_EN net)";
        } CONT1_EN[1] = 0;
        field {
            desc = "Enable for RAA229618 (U35) VDD_MEM_EFGH_A0 (and gates SP3_VDDCR_SOC_A0) 
            (PWR_CONT2_SP3_EN net)";
        } CONT2_EN[1] = 0;
        field {
            desc = "Pulsed according to AMD's EDS min 15ms (SP_TO_SP3_PWR_BTN_L net, inverted from this register)";
        } PWR_BTN[1] = 0;
        field {
            desc = "This is asserted to CPU, 1ms before asserting. Set when A0 rails are good. (SEQ_TO_SP3_PWR_GOOD net)";
        } PWR_GOOD[1] = 0;
        field {
            desc = "De-asserted to processor after GroupA supplies are stable (10ms after S5 rails minimum) 
            (SEQ_TO_SP3_RSMRST_V3P3_L net inverted from this register)";
        } RSMRST[1] = 0;
    };

    reg nic_output1_type {
        field {
            desc = "TurnsÂ onÂ V1P2_NIC_ENET_A0HP,Â noÂ readback (SEQ_TO_NIC_V1P2_ENET_EN net)";
        } NIC_V1P2_ETH_EN[1] = 0;
        field {
            desc = "EN0Â forÂ ISL68224Â (U357),Â V0P96_NIC_VDD_A0HP rail (PWR_CONT_NIC_EN0 net)";
        } NIC_CONT_EN0[1] = 0;
        field {
            desc = "EN1Â forÂ ISL68224Â (U357),Â V1P8_NIC_A0HP rail (PWR_CONT_NIC_EN1 ent)  ";
        } NIC_CONT_EN1[1] = 0;
        field {
            desc = "EnÂ forÂ V1P5_NIC_AVDD_A0HP rail (SEQ_TO_NIC_V1P5A_EN net)";
        } NIC_V1P5A_EN[1] = 0;
        field {
            desc = "EnÂ forÂ V1P5_NIC_PCIE_MEM_A0HP rail (SEQ_TO_NIC_V1P5D_EN net)";
        } NIC_V1P5D_EN[1] = 0;
        field {
            desc = "EnableÂ forÂ V1P2_NIC_MDIO_A0HP rail (SEQ_TO_NIC_V1P2_EN net)";
        } NIC_V1P2_EN[1] = 0;
        field {
            desc = "TurnsÂ onÂ V1P1_NIC_ETH_IO_A0HP rail (SEQ_TO_NIC_V1P1_EN net)";
        } NIC_V1P1_EN[1] = 0;
        field {
            desc = "EnablesÂ V3PV_NIC_A0HP rail (SEQ_TO_NIC_LDO_V3P3_EN net)";
        } NIC_V3P3[1] = 0;
    };

    reg nic_output2_type {
        field {
            desc = "Becomes clock enable for clk_100M_TO_RSW (SEQ_TO_NIC_COMB_PG net)";
        } NIC_COMB_PG[1] = 0;
        field {
            desc = "CLDÂ ResetÂ toÂ Chelsio. De-assertedÂ afterÂ NICÂ powerÂ stable (SEQ_TO_NIC_CLD_RST_L net inverted)";
        } NIC_CLD_RST[1] = 0;
        field {
            desc = "Alert SP3 of a NIC power fault (NIC_TO_SP3_PWRFLT_L inverted net)";
        } PWRFLT[1] = 0;
    };

    reg clk_gen_output_type {
        // TODO: need to understand GPIO pinouts and functions
        field {
            desc = "CLK_TO_SEQ_NMR_L inverted to clk generator";
        } SEQ_NMR[1] = 0;
    };

    reg amd_output_type {
        field {
            desc = "CPU's `SYS_RESET_L`, see EDS. 10ms assertion time, would traditionally be wired to a PC reset button";
        } SYS_RESET[1] = 0;
    };

    // Status registers
    a1_output_type OUTSTATUS_A1;
    OUTSTATUS_A1->name = "A1 Output readbacks"; 

    a0_output1_type OUTSTATUS_A0_1;
    OUTSTATUS_A0_1->name = "A0 Register 1 Output readbacks"; 
    a0_output2_type OUTSTATUS_A0_2;
    OUTSTATUS_A0_2->name = "A0 Register 2 Output readbacks";

    nic_output1_type OUTSTATUS_NIC1;
    OUTSTATUS_NIC1->name = "Readbacks of FPGA outputs (register 1 of 2) to NIC supplies/NIC";
    nic_output2_type OUTSTATUS_NIC2;
    OUTSTATUS_NIC2->name = "Readbacks of FPGA outputs (register 2 of 2) to NIC supplies/NIC";

    clk_gen_output_type OUTSTATUS_CLKGEN;
    OUTSTATUS_CLKGEN->name = "Readbacks of FPGA outputs to clock generator";

    amd_output_type OUTSTATUS_AMD;
    OUTSTATUS_AMD->name = "Readbacks of FPGA outputs to AMD";

    // Debug registers
    reg {
        name = "Debug Control register";
        field {
            desc = "Debug enable bit. Setting this flips a mux on FPGA output pins to
            be controlled by the following debug registers. If state maintence or pre-conditions
            are required you may use the next bit to capture the current state, or write to the
            debug registers to set up any desired pre-conditions";
        } REG_CTRL_EN[1] = 0;
        field {
            desc = "Self-clearing bit that will store the current output state in the debug registers";
            singlepulse = true;
        } STORE_CURRENT[1] = 0;
    } DBG_CTRL;

    a1_output_type DBGOUTA1;
    DBGOUTA1->name = "A1 Output debug control";  


    a0_output1_type DBGOUTA0_1;
    DBGOUTA0_1->name = "A0 Register 1 Output debug control"; 

    a0_output2_type DBGOUTA0_2;
    DBGOUTA0_2->name = "A0 Register 2 Output debug control"; 

    nic_output1_type DBGOUT_NIC1;
    DBGOUT_NIC1->name = "NIC REgister 1 Output debug control";
    nic_output2_type DBGOUT_NIC2;
    DBGOUT_NIC2->name = "Readbacks of FPGA outputs (register 2 of 2) to NIC supplies/NIC";

    clk_gen_output_type DBGOUT_CLKGEN;
    DBGOUT_CLKGEN->name = "Clock Generator Output readbacks";

    amd_output_type DBGOUT_AMD;
    DBGOUT_AMD->name = "Readbacks of FPGA outputs to AMD";
};