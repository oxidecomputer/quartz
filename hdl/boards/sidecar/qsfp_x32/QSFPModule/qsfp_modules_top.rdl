// Copyright 2022 Oxide Computer Company
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//
// QSFP Modules Top Address Map
//

addrmap qsfp_modules_top {
    name = "QSFP Module Top Registers";
    desc = "Collection of status and control registers for all QSFP modules";

    default regwidth = 8;
    default sw = rw;
    default hw = rw;

    //
    // I2C
    //

    reg {
        name = "QSFP module I2C address";

        field {
            desc = "I2C Address of QSFP module (reset: 7'b1010000)";
        } ADDR[6:0] = 7'b1010000;
    } I2C_BUS_ADDR;

    reg {
        name = "QSFP module register address";

        field {
            desc = "QSFP module register address";
        } ADDR[7:0] = 0;
    } I2C_REG_ADDR;

    reg {
        field {
            desc = "Number of bytes to read/write in the I2C transaction. up to 128 bytes.";
        } COUNT[7:0] = 1;
    } I2C_NUM_BYTES;

    reg {
        name = "Ports 8 -> 15 Broadcast Control";
        field {} PORT15[7:7] = 0;
        field {} PORT14[6:6] = 0;
        field {} PORT13[5:5] = 0;
        field {} PORT12[4:4] = 0;
        field {} PORT11[3:3] = 0;
        field {} PORT10[2:2] = 0;
        field {} PORT9[1:1] = 0;
        field {} PORT8[0:0] = 0;
    } I2C_BCAST_H;

    reg {
        name = "Ports 0 -> 7 Broadcast Control";
        field {} PORT7[7:7] = 0;
        field {} PORT6[6:6] = 0;
        field {} PORT5[5:5] = 0;
        field {} PORT4[4:4] = 0;
        field {} PORT3[3:3] = 0;
        field {} PORT2[2:2] = 0;
        field {} PORT1[1:1] = 0;
        field {} PORT0[0:0] = 0;
    } I2C_BCAST_L;

    reg {
        name = "Control bits for I2C communication.";

        field {
            desc = "2'b00 to read, 2'b01 to write, 2'b10 to random-read.";
        } OP[2:1] = 0;

        field {
            desc = "'1' to start next transaction.";
        } START[0:0] = 0;
    } I2C_CTRL;

    reg {
        default sw = r;
        name = "Ports 8 -> 15 I2C core status. '1' is busy.";
        field {} PORT15[7:7] = 0;
        field {} PORT14[6:6] = 0;
        field {} PORT13[5:5] = 0;
        field {} PORT12[4:4] = 0;
        field {} PORT11[3:3] = 0;
        field {} PORT10[2:2] = 0;
        field {} PORT9[1:1] = 0;
        field {} PORT8[0:0] = 0;
    } I2C_BUSY_H;

    reg {
        default sw = r;
        name = "Ports 0 -> 7 I2C core status. '1' is busy.";
        field {} PORT7[7:7] = 0;
        field {} PORT6[6:6] = 0;
        field {} PORT5[5:5] = 0;
        field {} PORT4[4:4] = 0;
        field {} PORT3[3:3] = 0;
        field {} PORT2[2:2] = 0;
        field {} PORT1[1:1] = 0;
        field {} PORT0[0:0] = 0;
    } I2C_BUSY_L;

    reg {
        default sw = r;
        name = "Ports 0/1 I2C core error status";
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT1_ERROR[7:7] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT1_ERROR_TYPE[6:4] = 0;
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT0_ERROR[3:3] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT0_ERROR_TYPE[2:0] = 0;
    } I2C_ERROR_0_1;

    reg {
        default sw = r;
        name = "Ports 2/3 I2C core error status";
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT3_ERROR[7:7] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT3_ERROR_TYPE[6:4] = 0;
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT2_ERROR[3:3] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT2_ERROR_TYPE[2:0] = 0;
    } I2C_ERROR_2_3;

    reg {
        default sw = r;
        name = "Ports 4/5 I2C core error status";
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT5_ERROR[7:7] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT5_ERROR_TYPE[6:4] = 0;
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT4_ERROR[3:3] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT4_ERROR_TYPE[2:0] = 0;
    } I2C_ERROR_4_5;

    reg {
        default sw = r;
        name = "Ports 6/7 I2C core error status";
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT7_ERROR[7:7] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT7_ERROR_TYPE[6:4] = 0;
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT6_ERROR[3:3] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT6_ERROR_TYPE[2:0] = 0;
    } I2C_ERROR_6_7;

    reg {
        default sw = r;
        name = "Ports 8/9 I2C core error status";
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT9_ERROR[7:7] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT9_ERROR_TYPE[6:4] = 0;
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT8_ERROR[3:3] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT8_ERROR_TYPE[2:0] = 0;
    } I2C_ERROR_8_9;

    reg {
        default sw = r;
        name = "Ports 10/11 I2C core error status";
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT11_ERROR[7:7] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT11_ERROR_TYPE[6:4] = 0;
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT10_ERROR[3:3] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT10_ERROR_TYPE[2:0] = 0;
    } I2C_ERROR_10_11;

    reg {
        default sw = r;
        name = "Ports 12/13 I2C core error status";
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT13_ERROR[7:7] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT13_ERROR_TYPE[6:4] = 0;
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT12_ERROR[3:3] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT12_ERROR_TYPE[2:0] = 0;
    } I2C_ERROR_12_13;

    reg {
        default sw = r;
        name = "Ports 14/15 I2C core error status";
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT15_ERROR[7:7] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT15_ERROR_TYPE[6:4] = 0;
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } PORT14_ERROR[3:3] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } PORT14_ERROR_TYPE[2:0] = 0;
    } I2C_ERROR_14_15;

    //
    // QSFP Module Control
    //

    reg {
        name = "Ports 8 -> 15 Enable Control";
        field {} PORT15[7:7] = 0;
        field {} PORT14[6:6] = 0;
        field {} PORT13[5:5] = 0;
        field {} PORT12[4:4] = 0;
        field {} PORT11[3:3] = 0;
        field {} PORT10[2:2] = 0;
        field {} PORT9[1:1] = 0;
        field {} PORT8[0:0] = 0;
    } CTRL_EN_H;

    reg {
        name = "Ports 0 -> 7 Enable Control";
        field {} PORT7[7:7] = 0;
        field {} PORT6[6:6] = 0;
        field {} PORT5[5:5] = 0;
        field {} PORT4[4:4] = 0;
        field {} PORT3[3:3] = 0;
        field {} PORT2[2:2] = 0;
        field {} PORT1[1:1] = 0;
        field {} PORT0[0:0] = 0;
    } CTRL_EN_L;

    reg {
        name = "Ports 8 -> 15 Reset Control (logic inverted at the pin)";
        field {} PORT15[7:7] = 1;
        field {} PORT14[6:6] = 1;
        field {} PORT13[5:5] = 1;
        field {} PORT12[4:4] = 1;
        field {} PORT11[3:3] = 1;
        field {} PORT10[2:2] = 1;
        field {} PORT9[1:1] = 1;
        field {} PORT8[0:0] = 1;
    } CTRL_RESET_H;

    reg {
        name = "Ports 0 -> 7 Reset Control (logic inverted at the pin)";
        field {} PORT7[7:7] = 1;
        field {} PORT6[6:6] = 1;
        field {} PORT5[5:5] = 1;
        field {} PORT4[4:4] = 1;
        field {} PORT3[3:3] = 1;
        field {} PORT2[2:2] = 1;
        field {} PORT1[1:1] = 1;
        field {} PORT0[0:0] = 1;
    } CTRL_RESET_L;

    reg {
        name = "Ports 8 -> 15 LPMode/TxDis Control";
        field {} PORT15[7:7] = 1;
        field {} PORT14[6:6] = 1;
        field {} PORT13[5:5] = 1;
        field {} PORT12[4:4] = 1;
        field {} PORT11[3:3] = 1;
        field {} PORT10[2:2] = 1;
        field {} PORT9[1:1] = 1;
        field {} PORT8[0:0] = 1;
    } CTRL_LPMODE_H;

    reg {
        name = "Ports 0 -> 7 LPMode/TxDis Control";
        field {} PORT7[7:7] = 1;
        field {} PORT6[6:6] = 1;
        field {} PORT5[5:5] = 1;
        field {} PORT4[4:4] = 1;
        field {} PORT3[3:3] = 1;
        field {} PORT2[2:2] = 1;
        field {} PORT1[1:1] = 1;
        field {} PORT0[0:0] = 1;
    } CTRL_LPMODE_L;

    //
    // QSFP Module Status
    //

    reg {
        name = "Ports 8 -> 15 HSC power good";
        default sw = r;
        field {} PORT15[7:7] = 0;
        field {} PORT14[6:6] = 0;
        field {} PORT13[5:5] = 0;
        field {} PORT12[4:4] = 0;
        field {} PORT11[3:3] = 0;
        field {} PORT10[2:2] = 0;
        field {} PORT9[1:1] = 0;
        field {} PORT8[0:0] = 0;
    } STATUS_PG_H;

    reg {
        name = "Ports 0 -> 7 HSC power good";
        default sw = r;
        field {} PORT7[7:7] = 0;
        field {} PORT6[6:6] = 0;
        field {} PORT5[5:5] = 0;
        field {} PORT4[4:4] = 0;
        field {} PORT3[3:3] = 0;
        field {} PORT2[2:2] = 0;
        field {} PORT1[1:1] = 0;
        field {} PORT0[0:0] = 0;
    } STATUS_PG_L;

    reg {
        name = "Ports 8 -> 15 HSC power good timeout";
        default sw = r;
        field {} PORT15[7:7] = 0;
        field {} PORT14[6:6] = 0;
        field {} PORT13[5:5] = 0;
        field {} PORT12[4:4] = 0;
        field {} PORT11[3:3] = 0;
        field {} PORT10[2:2] = 0;
        field {} PORT9[1:1] = 0;
        field {} PORT8[0:0] = 0;
    } STATUS_PG_TIMEOUT_H;

    reg {
        name = "Ports 0 -> 7 HSC power good timeout";
        default sw = r;
        field {} PORT7[7:7] = 0;
        field {} PORT6[6:6] = 0;
        field {} PORT5[5:5] = 0;
        field {} PORT4[4:4] = 0;
        field {} PORT3[3:3] = 0;
        field {} PORT2[2:2] = 0;
        field {} PORT1[1:1] = 0;
        field {} PORT0[0:0] = 0;
    } STATUS_PG_TIMEOUT_L;

    reg {
        name = "Ports 8 -> 15 ModPrsL signal for the module (logic inverted at the pin)";
        default sw = r;
        field {} PORT15[7:7] = 0;
        field {} PORT14[6:6] = 0;
        field {} PORT13[5:5] = 0;
        field {} PORT12[4:4] = 0;
        field {} PORT11[3:3] = 0;
        field {} PORT10[2:2] = 0;
        field {} PORT9[1:1] = 0;
        field {} PORT8[0:0] = 0;
    } STATUS_PRESENT_H;

    reg {
        name = "Ports 0 -> 7 ModPrsL signal for the module (logic inverted at the pin)";
        default sw = r;
        field {} PORT7[7:7] = 0;
        field {} PORT6[6:6] = 0;
        field {} PORT5[5:5] = 0;
        field {} PORT4[4:4] = 0;
        field {} PORT3[3:3] = 0;
        field {} PORT2[2:2] = 0;
        field {} PORT1[1:1] = 0;
        field {} PORT0[0:0] = 0;
    } STATUS_PRESENT_L;

    reg {
        name = "Ports 8 -> 15 IntL/RxLOS signal for the module (logic inverted at the pin)";
        default sw = r;
        field {} PORT15[7:7] = 0;
        field {} PORT14[6:6] = 0;
        field {} PORT13[5:5] = 0;
        field {} PORT12[4:4] = 0;
        field {} PORT11[3:3] = 0;
        field {} PORT10[2:2] = 0;
        field {} PORT9[1:1] = 0;
        field {} PORT8[0:0] = 0;
    } STATUS_IRQ_H;

    reg {
        name = "Ports 0 -> 7 IntL/RxLOS signal for the module (logic inverted at the pin)";
        default sw = r;
        field {} PORT7[7:7] = 0;
        field {} PORT6[6:6] = 0;
        field {} PORT5[5:5] = 0;
        field {} PORT4[4:4] = 0;
        field {} PORT3[3:3] = 0;
        field {} PORT2[2:2] = 0;
        field {} PORT1[1:1] = 0;
        field {} PORT0[0:0] = 0;
    } STATUS_IRQ_L;

    //
    // I2C Write and Read Buffers
    // Status register colocated with the read buffer so we can grab the status
    // and all the bits in the same transaction.
    //

    reg port_i2c_status {
        default sw = r;
        field {
            desc = "'1' if the bus is busy.";
        } BUSY[4:4] = 0;
        field {
            desc = "'1' if there was an error on the most recent transaction done by this port.";
        } ERROR[3:3] = 0;
        field {
            desc = "Valid if ERROR is set. 3'b000 for AddressNack, 3'b001 for ByteNack.";
        } ERROR_TYPE[2:0] = 0;
    };

    mem read_buffer {
        mementries = 128;
        memwidth = 8;
    };

    mem write_buffer {
        mementries = 128;
        memwidth = 8;
    };

    port_i2c_status PORT0_I2C_STATUS @0x007F;
    external read_buffer PORT0_READ_BUFFER @0x0080;

    port_i2c_status PORT1_I2C_STATUS @0x017F;
    external read_buffer PORT1_READ_BUFFER @0x0180;

    port_i2c_status PORT2_I2C_STATUS @0x027F;
    external read_buffer PORT2_READ_BUFFER @0x0280;

    port_i2c_status PORT3_I2C_STATUS @0x037F;
    external read_buffer PORT3_READ_BUFFER @0x0380;

    port_i2c_status PORT4_I2C_STATUS @0x047F;
    external read_buffer PORT4_READ_BUFFER @0x0480;

    port_i2c_status PORT5_I2C_STATUS @0x057F;
    external read_buffer PORT5_READ_BUFFER @0x0580;

    port_i2c_status PORT6_I2C_STATUS @0x067F;
    external read_buffer PORT6_READ_BUFFER @0x0680;

    port_i2c_status PORT7_I2C_STATUS @0x077F;
    external read_buffer PORT7_READ_BUFFER @0x0780;

    port_i2c_status PORT8_I2C_STATUS @0x087F;
    external read_buffer PORT8_READ_BUFFER @0x0880;

    port_i2c_status PORT9_I2C_STATUS @0x097F;
    external read_buffer PORT9_READ_BUFFER @0x0980;

    port_i2c_status PORT10_I2C_STATUS @0x0A7F;
    external read_buffer PORT10_READ_BUFFER @0x0A80;

    port_i2c_status PORT11_I2C_STATUS @0x0B7F;
    external read_buffer PORT11_READ_BUFFER @0x0B80;

    port_i2c_status PORT12_I2C_STATUS @0x0C7F;
    external read_buffer PORT12_READ_BUFFER @0x0C80;

    port_i2c_status PORT13_I2C_STATUS @0x0D7F;
    external read_buffer PORT13_READ_BUFFER @0x0D80;

    port_i2c_status PORT14_I2C_STATUS @0x0E7F;
    external read_buffer PORT14_READ_BUFFER @0x0E80;

    port_i2c_status PORT15_I2C_STATUS @0x0F7F;
    external read_buffer PORT15_READ_BUFFER @0x0F80;

    external write_buffer WRITE_BUFFER;
};
