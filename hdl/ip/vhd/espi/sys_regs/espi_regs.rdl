// Copyright 2024 Oxide Computer Company
// This is SystemRDL description of the sw-accessible registers in the Gimlet
// Sequencer FPGA.

property addr_span_bytes {
    type=number;
    component=addrmap;
    default=0x100;
    };

addrmap espi_regs {
    
    name = "espi system registers";
    desc = "Registers accessible on the Axi bus for debug and testing of the espi target";

    default regwidth = 32;
    default sw = rw;
    default hw = r;

    reg {
        name = "Flags Register";
        desc = "";

        field {
            default sw = woclr;
            desc = "Sticky bit for alert, set to 1 when alert is needed, cleared by writing 1";
        } alert[0:0] =  0;
    } flags;

    reg {
        name = "Control Register";
        desc = "";
        field {
            desc = "Issue an espi reset via the debug logic. Cleared by hardware after reset.";
        } espi_reset[5:5] =  0;
        field {
            desc = "Set to one to reset the command FIFO. Cleared by hardware after reset.";
        } cmd_fifo_reset[3:3] =  0;
         field {
            desc = "Set to one to reset the command size FIFO. Cleared by hardware after reset.";
        } cmd_size_fifo_reset[2:2] =  0;
        field {
            desc = "Set to one to reset response FIFO. Cleared by hardware after reset.";
        } resp_fifo_reset[1:1] =  0;
        field {
            desc = "Set to one mux in the debug FIFOs and ignore the real eSPI interface";
        } dbg_mode_en[0:0] =  0;   
    } control;

    reg {
        name = "Status Register";
        desc = "";

        field {
            default sw = r;
            desc = "Set to one to 1 when hw is running the spi transaction, no new transactions
            may be issued until it is finished. Technically represents cs_n being low.";
        } busy[0:0] =  0;

    } status;

    reg {
        name = "Fifo Status Register";
        desc = "";
        field {
            default sw = r;
            desc = "Show used words in command FIFO (word = 32bits/4 bytes),
            1024 words so 4kB";
        } cmd_used_wds[31:16] =  0;

        field {
            default sw = r;
            desc = "Show used FIFO words in response FIFO (word = 32bits/4 bytes),
            1024 words so 4kB";
        } resp_used_wds[15:0] =  0;
    } fifo_status;

    reg {
        name = "Command FIFO Write Data Register";
        desc = "";
        field {
            desc = "Writing stores data in fifo";
        } fifo_data[31:0] =  0;
     } cmd_fifo_wdata;

    reg {
        name = "Response FIFO Read Data Register";
        desc = "";
        field {
            desc = "Note: Reading side-effects the data by popping the fifo";
        } fifo_data[31:0] =  0;
    } resp_fifo_rdata;

    reg {
        name = "Command FIFO Byte Count FIFO";
        desc = "";
        field {
            desc = "store command byte size in fifo. Because we are sending 4bytes at a time into the fifo, but only reading
            1 byte at a time, we need to store the number of cmd bytes in the fifo. This allows queueing up multiple commands
            if desired. left over data bytes are discarded if this fifo is empty and there are <4 bytes left in cmd_fifo";
        } fifo_data[7:0] =  0;
     } cmd_size_fifo_wdata;

    reg {
        name = "UART Avail Threshold Bytes";
        desc = "";
        field {
            desc = "";
        } bytes[7:0] =  32;
     } uart_thresh;

    reg {
        name = "Last Post Code (0x47 PUT_IOWR_SHORT) Payload";
        desc = "";
        field {
            desc = "MSB is bit 31";
        } payload[31:0] =  0;
    } last_post_code;

    reg {
        name = "Post Code Counter";
        desc = "Count of valid post codes seen since reset. Can also be reset by espi_reset.";
        field {
            desc = "";
        } count[31:0] = 0;
    } post_code_count;

    reg {
        name = "IPCC_SP_TO_HOST_USEDWDS";
        desc = "Count of usedwds in the IPCC to host TX FIFO";
        field {
            desc = "";
        } count[31:0] = 0;
    } ipcc_to_host_usedwds;

    reg {
        name = "IPCC_HOST_TO_SP_USEDWDS";
        desc = "Count of used words in the host-to-SP IPCC RX FIFO";
        field {
            default sw = r;
            desc = "";
        } count[31:0] = 0;
    } ipcc_host_to_sp_usedwds;

    reg {
        name = "IPCC_TO_HOST_BYTE_CNTR";
        desc = "Count of total bytes sent to host via IPCC UART channel since reset";
        field {
            desc = "";
        } count[31:0] = 0;
    } ipcc_to_host_byte_cntr;

    reg {
        name = "IPCC DUMMY FILL EN";
        desc = "Enable this to do a 1 time FIFO fill with dummy count (next register) bytes into the ipcc FIFO when oob channel is enabled";
        field {
            desc = "";
        } en[0:0] = 0;
    } ipcc_dummy_fill_en;

    reg {
        name = "IPCC DUMMY FILL COUNT";
        desc = "Count of dummy bytes to be filled into IPCC FIFO when dummy fill is enabled. 1 time fill on enable after espi reset.";
        field {
            desc = "";
        } count[31:0] = 0;
    } ipcc_dummy_fill_count;

    reg espi_status {
        field {
            desc = "When '1', indicates the target has a channel 3
                Flash Access non-posted header and data up to
                maximum payload size available to send.
                This bit is only applicable when controller
                attached flash sharing is supported and in
                operation. Otherwise, the bit is a don't care.";
        } FLASH_NP_AVAIL[13:13];
        field {
            desc = "When '1', indicates the target has a channel 3
                Flash Access completion header and data up to
                maximum payload size available to send.
                This bit is only applicable when target attached
                flash sharing is supported and in operation.
                Otherwise, the bit is a don't care.";
        } FLASH_C_AVAIL[12:12];
        field {
            desc = "When '1', indicates the target is free to accept
                at least one channel 3 Flash Access non-posted
                header and data up to maximum payload size.
                This bit is only applicable when target attached
                flash sharing is supported and in operation.
                Otherwise, the bit is a don't care.";
        } FLASH_NP_FREE[9:9];
        field {
            desc = "When '1', indicates the target is free to accept
                at least one channel 3 Flash Access completion
                header and data up to maximum payload size.
                This bit must be always a '1'. The target must
                be able to accept the completion for the non-
                posted request it sends.
                This bit is only applicable when controller
                attached flash sharing is supported and in
                operation. Otherwise, the bit is a don't care.";
        } FLASH_C_FREE[8:8];
        field {
            desc = "When '1', indicates the target has a channel 2
                OOB (tunneled SMBus) message with data up
                to maximum payload size available to send.";
        } OOB_AVAIL[7:7];
        field {
            desc = "When '1', indicates the target has a channel 1
                tunneled virtual wire available to send.";
        } VWIRE_AVAIL[6:6];
         field {
            desc = "When '1', indicates the target has a channel 0
                peripheral non-posted header available to
                send.";
        } NP_AVAIL[5:5];

        field {
            desc = "When '1', indicates the target has a channel 0
                peripheral posted or completion header and
                optional data up to maximum payload size
                available to send.";
        } PC_AVAIL[4:4];
        
        field {
            desc = "When '1', indicates the target is free to accept
                at least one channel 2 OOB (tunneled SMBus)
                message with data up to maximum payload size.";
        } OOB_FREE[3:3];
         field {
            desc = "This bit must be always a '1'. Tunneling of
                channel 1 virtual wires is not flow controlled.";
        } VWIRE_FREE[2:2];
         field {
            desc = "When '1', indicates the target is free to accept
                at least one channel 0 peripheral non-posted
                header and 1 DW of Data (if applicable).";
        } NP_FREE[1:1];
        field {
            desc = "When '1', indicates the target is free to accept
            at least one channel 0 peripheral posted or
            completion header and data up to maximum
            payload size.";
        } PC_FREE[0:0];
        
    };

    espi_status LIVE_ESPI_STATUS;
    LIVE_ESPI_STATUS->name = "LIVE_ESPI_STATUS"; 

    espi_status LAST_RESP_STATUS;
    LAST_RESP_STATUS->name = "LAST_RESP_STATUS";


    reg {
        name = "OOB_FREE_SAW_FULL";
        desc = "Sticky bit: set to 1 if oob_free ever went low (RX FIFO nearly full) since last eSPI reset. Cleared only by eSPI reset.";
        field {
            default sw = r;
            desc = "";
        } saw_full[0:0] = 0;
    } oob_free_saw_full;

    // Read-only view of the eSPI spec registers, so the SP can
    // observe what the eSPI host has configured.
    eSPI_Spec spec_regs @ 0x0080;

     mem post_code_buffer_mem {
        mementries = 4096;
        memwidth = 32;
    };

    external post_code_buffer_mem post_code_buffer @0x0100;
};