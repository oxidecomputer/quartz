-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at https://mozilla.org/MPL/2.0/.
--
-- Copyright 2025 Oxide Computer Company

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std_unsigned.all;

use work.pca9506_regs_pkg.all;

package pca9506_pkg is

    type cmd_t is record
        ai : std_logic; -- auto-increment
        pointer: std_logic_vector(5 downto 0); -- register number
    end record; -- default to 0x80

    constant default_reset : cmd_t := (
        ai => '1',
        pointer => (others => '0')
    );

    type pca9506_pin_t is array (0 to 4) of std_logic_vector(7 downto 0);
    type multiple_pca9506_pin_t is array (natural range <>) of pca9506_pin_t;

    function get_irq_pend(
        cur_reg: io_type;
        reg_at_last_read: io_type;
        reg_mask: io_type
    ) return std_logic;

    -- PCA9506 defines a category as a set of contiguous registers of the
    -- same function for each of the  5 ports.  When auto-incrementing is
    -- enabled, the pointer will wrap around to the first register of the
    -- category when it reaches the last register of the category.
    -- Because there  are 5 ports, there are 5 registers in each category
    -- so we can't just use a power of 2 that wraps and we wrote this 
    -- function.
    function category_wrapping_increment(
        pointer: std_logic_vector(5 downto 0) -- register number
    ) return std_logic_vector;

    function pi_reads_inputs_or_outputs(
        io: io_type;
        op: io_type;
        ioc: io_type
    ) return io_type ;


end package;

package body pca9506_pkg is

    function get_irq_pend(
        cur_reg: io_type;
        reg_at_last_read: io_type;
        reg_mask: io_type
    ) return std_logic
    is

    begin
        -- bitwise XOR current register with last to detect any changes
        -- then bitwise mask off any masked bits
        -- for the mask, '1' indicates "masked" so we need a bitwise inversion
        -- before the bitwise AND for masking.
        -- Finally, we need to reduce this down to a single bit to return,
        -- We don't currently support unary reduction operators for record
        -- types generated by RDL so we use the "compress" function to get
        -- back a std_logic_vector of the used bits, and then we use a unary
        -- reduction "or" operator on that to return 1 if any bits were 1
        return or compress((cur_reg xor reg_at_last_read) and (not reg_mask));
    end function;

    function category_wrapping_increment(
        pointer: std_logic_vector(5 downto 0) -- register number
    ) return std_logic_vector is
        variable lsbs : std_logic_vector(2 downto 0);

    begin
        lsbs := pointer(2 downto 0) + 1;
        if lsbs > 4 then
            lsbs := (others => '0');
        end if;

        -- increment the 3 lsb by one from 0 to 4, wrapping around to 0
        return pointer(5 downto 3) & lsbs;
    end function;

    function pi_reads_inputs_or_outputs(
        io: io_type;
        op: io_type;
        ioc: io_type
    ) return io_type is
        variable pi : io_type;
    begin
        for i in io.bits'range loop
            if ioc.bits(i) = '0' then
                -- this pin is an output, we should "read" the output value
                -- as an input
                pi.bits(i) := op.bits(i);
            else
                -- this pin is an input, we should "read" the input value
                -- as an input
                pi.bits(i) := io.bits(i);
            end if;
        end loop;
        return pi;
    end function;
end package body pca9506_pkg;