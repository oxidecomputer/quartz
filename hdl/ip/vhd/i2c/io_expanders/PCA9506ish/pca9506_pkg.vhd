-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at https://mozilla.org/MPL/2.0/.
--
-- Copyright 2025 Oxide Computer Company

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std_unsigned.all;

use work.pca9506_regs_pkg.all;

package pca9506_pkg is

    type cmd_t is record
        ai : std_logic; -- auto-increment
        pointer: std_logic_vector(5 downto 0); -- register number
    end record; -- default to 0x80

    constant default_reset : cmd_t := (
        ai => '1',
        pointer => (others => '0')
    );

    type pca9506_pin_t is array (0 to 4) of std_logic_vector(7 downto 0);

    function get_irq_pend(
        cur_reg: io_type;
        reg_at_last_read: io_type;
        reg_mask: io_type
    ) return std_logic;

    function category_wrapping_increment(
        pointer: std_logic_vector(5 downto 0) -- register number
    ) return std_logic_vector;



end package;

package body pca9506_pkg is

    function get_irq_pend(
        cur_reg: io_type;
        reg_at_last_read: io_type;
        reg_mask: io_type
    ) return std_logic
    is

    begin
        -- bitwise XOR current register with last to detect any changes
        -- then bitwise mask off any masked bits
        -- for the mask, '1' indicates "masked" so we need a bitwise inversion
        -- before the bitwise AND for masking.
        -- Finally, we need to reduce this down to a single bit to return,
        -- We don't currently support unary reduction operators for record
        -- types generated by RDL so we use the "compress" function to get
        -- back a std_logic_vector of the used bits, and then we use a unary
        -- reduction "or" operator on that to return 1 if any bits were 1
        return or compress((cur_reg xor reg_at_last_read) and (not reg_mask));
    end function;

    function category_wrapping_increment(
        pointer: std_logic_vector(5 downto 0) -- register number
    ) return std_logic_vector is
        variable lsbs : std_logic_vector(2 downto 0);

    begin
        lsbs := pointer(2 downto 0) + 1;
        if lsbs > 4 then
            lsbs := (others => '0');
        end if;

        -- increment the 3 lsb by one from 0 to 4, wrapping around to 0
        return pointer(5 downto 3) & lsbs;
    end function;
end package body pca9506_pkg;